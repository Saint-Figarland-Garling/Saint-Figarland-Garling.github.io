<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hybrid AI Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
        
        /* UI Overlay */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            color: #00ffcc;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1rem; border-bottom: 1px solid #00ffcc; padding-bottom: 5px; }
        .data-row { display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.85rem; }
        .val { color: #fff; font-weight: bold; }
        
        /* The "Chat" from the System */
        #ai-log {
            margin-top: 20px;
            height: 100px;
            overflow: hidden;
            border-left: 2px solid #00ffcc;
            padding-left: 10px;
            font-size: 0.8rem;
            color: #aaa;
            mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
        }
        .ai-msg { margin-bottom: 5px; animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

        /* Camera Feed */
        #webcam {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            border-radius: 8px;
            border: 1px solid #333;
            transform: scaleX(-1);
            opacity: 0.6;
        }
        
        /* Loading/Status */
        #status {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            pointer-events: none;
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="hud">
        <h1>SYSTEM STATUS: ONLINE</h1>
        <div class="data-row"><span>GESTURE:</span> <span id="gesture-disp" class="val">Detecting...</span></div>
        <div class="data-row"><span>CONFIDENCE:</span> <span id="conf-disp" class="val">0%</span></div>
        <div class="data-row"><span>FINGERS:</span> <span id="finger-disp" class="val">[0,0,0,0,0]</span></div>
        
        <div id="ai-log">
            <div class="ai-msg">> Initializing Neural Link...</div>
        </div>
    </div>

    <div id="status">Loading Vision Models...</div>
    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONSTANTS & CONFIG ---
        const CONFIG = {
            particleCount: 12000,
            baseColor: new THREE.Color(0x00ffcc),
            lerpSpeed: 0.05
        };

        // --- THREE.JS SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const colorTargets = new Float32Array(CONFIG.particleCount * 3);

        // Initialize
        for(let i=0; i<CONFIG.particleCount; i++) {
            const idx = i*3;
            positions[idx] = (Math.random()-0.5)*40;
            positions[idx+1] = (Math.random()-0.5)*40;
            positions[idx+2] = (Math.random()-0.5)*40;
            
            // Set initial color targets
            colorTargets[idx] = CONFIG.baseColor.r;
            colorTargets[idx+1] = CONFIG.baseColor.g;
            colorTargets[idx+2] = CONFIG.baseColor.b;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            map: createCircleTexture() // Soft particles
        });

        const particleSystem = new THREE.Points(particles, material);
        scene.add(particleSystem);

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        // --- GESTURE LOGIC (The "Smart" Local Brain) ---
        // We use vector geometry to determine which fingers are extended
        function getFingerStates(landmarks) {
            // Finger Tips: [4, 8, 12, 16, 20]
            // Finger PIPs (Knuckles): [2, 6, 10, 14, 18]
            // Wrist: 0
            
            const states = []; // [Thumb, Index, Middle, Ring, Pinky]
            const wrist = landmarks[0];

            // 1. Thumb Check (Check X distance relative to wrist/knuckle)
            const thumbTip = landmarks[4];
            const thumbIp = landmarks[3];
            // Simple heuristic for thumb: is tip further from palm center than IP?
            states.push(Math.abs(thumbTip.x - landmarks[17].x) > Math.abs(thumbIp.x - landmarks[17].x) ? 1 : 0);

            // 2. Fingers Check (Y distance: Tip higher than PIP)
            // Note: MediaPipe Y is inverted (0 is top). So smaller Y = higher.
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            
            for(let i=0; i<4; i++) {
                // We use distance to wrist to determine extension regardless of hand rotation
                const dTip = Math.hypot(landmarks[tips[i]].x - wrist.x, landmarks[tips[i]].y - wrist.y);
                const dPip = Math.hypot(landmarks[pips[i]].x - wrist.x, landmarks[pips[i]].y - wrist.y);
                states.push(dTip > dPip * 1.2 ? 1 : 0); // 1.2 threshold prevents flicker
            }
            return states;
        }

        function matchGesture(states) {
            const s = states.join('');
            if (s === '00000' || s === '10000') return 'FIST'; // Thumb can be tricky
            if (s === '11111' || s === '01111') return 'OPEN';
            if (s === '01100' || s === '11100') return 'PEACE';
            if (s === '01000' || s === '11000') return 'POINT';
            if (s === '01001' || s === '11001') return 'ROCK';
            return 'UNKNOWN';
        }

        // --- SHAPE GENERATORS ---
        function updateShape(type) {
            logAI(`Morphing geometry to: ${type}`);
            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                let x,y,z;

                if(type === 'FIST') { // Black Hole / Collapse
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    const r = Math.random() * 2; // Tight center
                    x = r * Math.sin(v) * Math.cos(u);
                    y = r * Math.sin(v) * Math.sin(u);
                    z = r * Math.cos(v);
                    
                    // Red/Orange angry colors
                    colorTargets[idx] = 1.0; colorTargets[idx+1] = 0.2; colorTargets[idx+2] = 0.0;
                }
                else if(type === 'OPEN') { // Galaxy / Cloud
                    const angle = Math.random() * Math.PI * 2;
                    const r = 10 + Math.random() * 15;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r;
                    y = (Math.random() - 0.5) * 5;
                    
                    // Cyan/Blue calm colors
                    colorTargets[idx] = 0.0; colorTargets[idx+1] = 0.8; colorTargets[idx+2] = 1.0;
                }
                else if(type === 'PEACE') { // Double Helix / DNA
                    const t = (i / CONFIG.particleCount) * Math.PI * 20;
                    x = Math.sin(t) * 5;
                    z = Math.cos(t) * 5;
                    y = (i / CONFIG.particleCount) * 40 - 20;
                    if (i % 2 === 0) x *= -1; // Double strand

                    // Green/Nature colors
                    colorTargets[idx] = 0.2; colorTargets[idx+1] = 1.0; colorTargets[idx+2] = 0.5;
                }
                else if(type === 'ROCK') { // Chaotic Explosion
                     x = (Math.random() - 0.5) * 50;
                     y = (Math.random() - 0.5) * 50;
                     z = (Math.random() - 0.5) * 50;
                     // Purple/Pink Electric
                     colorTargets[idx] = 0.8; colorTargets[idx+1] = 0.0; colorTargets[idx+2] = 1.0;
                }
                else if(type === 'POINT') { // Stream / Arrow
                    x = (Math.random() - 0.5) * 5;
                    y = (Math.random() - 0.5) * 5;
                    z = (i / CONFIG.particleCount) * 40 - 20; // Long line
                    // White/Yellow
                    colorTargets[idx] = 1.0; colorTargets[idx+1] = 1.0; colorTargets[idx+2] = 0.5;
                }

                // If undefined (transition), keep old target
                if(x !== undefined) {
                    targets[idx] = x;
                    targets[idx+1] = y;
                    targets[idx+2] = z;
                }
            }
        }

        // --- VISION SETUP ---
        let handLandmarker;
        let lastVideoTime = -1;
        let lastGesture = '';
        let gestureHoldTime = 0;

        async function initVision() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO",
                numHands: 1
            });
            document.getElementById('status').style.display = 'none';
            startCamera();
        }

        function startCamera() {
            const video = document.getElementById('webcam');
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                animate();
            });
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const video = document.getElementById('webcam');

            // 1. VISION PROCESSING
            if (handLandmarker && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];
                    
                    // A. Calculate Finger States (The "Smart" Logic)
                    const states = getFingerStates(landmarks);
                    const gestureName = matchGesture(states);

                    // UI Updates
                    document.getElementById('finger-disp').innerText = JSON.stringify(states);
                    document.getElementById('gesture-disp').innerText = gestureName;
                    document.getElementById('conf-disp').innerText = "98%"; // Geometric calculation is high confidence

                    // B. State Machine (Debouncing)
                    // Only switch if we hold the gesture for 10 frames to avoid flickering
                    if (gestureName === lastGesture) {
                        gestureHoldTime++;
                        if (gestureHoldTime === 10 && gestureName !== 'UNKNOWN') {
                            updateShape(gestureName);
                            // Here is where you would trigger the Real LLM if you wanted
                            // consultRealLLM(gestureName); 
                        }
                    } else {
                        lastGesture = gestureName;
                        gestureHoldTime = 0;
                    }

                    // C. Interaction (Move center of cloud)
                    // Map palm (0) to 3D space
                    const cx = (0.5 - landmarks[0].x) * 30; // Mirror X
                    const cy = (0.5 - landmarks[0].y) * 20;
                    
                    // Soft follow
                    scene.position.x += (cx - scene.position.x) * 0.1;
                    scene.position.y += (cy - scene.position.y) * 0.1;
                }
            }

            // 2. PARTICLE PHYSICS
            const p = particles.attributes.position.array;
            const c = particles.attributes.color.array;

            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                
                // Position Lerp
                p[idx] += (targets[idx] - p[idx]) * CONFIG.lerpSpeed;
                p[idx+1] += (targets[idx+1] - p[idx+1]) * CONFIG.lerpSpeed;
                p[idx+2] += (targets[idx+2] - p[idx+2]) * CONFIG.lerpSpeed;

                // Color Lerp
                c[idx] += (colorTargets[idx] - c[idx]) * 0.05;
                c[idx+1] += (colorTargets[idx+1] - c[idx+1]) * 0.05;
                c[idx+2] += (colorTargets[idx+2] - c[idx+2]) * 0.05;

                // Add Noise/Life
                p[idx] += (Math.random()-0.5) * 0.05;
                p[idx+1] += (Math.random()-0.5) * 0.05;
            }
            
            particles.attributes.position.needsUpdate = true;
            particles.attributes.color.needsUpdate = true;
            
            // Rotate the whole system slowly
            particleSystem.rotation.y += 0.002;

            renderer.render(scene, camera);
        }

        // --- UI HELPERS ---
        function logAI(msg) {
            const log = document.getElementById('ai-log');
            const div = document.createElement('div');
            div.className = 'ai-msg';
            div.innerText = `> ${msg}`;
            log.prepend(div);
            if(log.children.length > 5) log.lastChild.remove();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initVision();
    </script>
</body>
</html>
