<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gemini-Powered Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
        
        /* HUD UI */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            color: #00ffcc;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 20, 20, 0.6);
            padding: 15px;
            border: 1px solid #00ffcc;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
        }
        h1 { margin: 0 0 10px 0; font-size: 1rem; border-bottom: 1px solid #00ffcc; padding-bottom: 5px; }
        .data-row { display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.85rem; }
        .val { color: #fff; font-weight: bold; }
        
        /* AI Log */
        #ai-log {
            margin-top: 15px;
            height: 120px;
            overflow-y: auto;
            border-top: 1px dashed #00ffcc;
            padding-top: 5px;
            font-size: 0.75rem;
            color: #aaa;
        }
        .ai-msg { margin-bottom: 4px; animation: fadeIn 0.5s ease; }
        .ai-loading { color: #ffff00; animation: pulse 1s infinite; }
        
        /* Webcam Preview */
        #webcam {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            border-radius: 8px;
            border: 2px solid #333;
            transform: scaleX(-1); /* Mirror effect */
            opacity: 0.8;
            z-index: 100;
        }

        /* Loading Screen */
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00ffcc;
            z-index: 999;
            font-size: 1.5rem;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loader">Initializing Neural Uplink...</div>

    <div id="hud">
        <h1>GEMINI INTERFACE</h1>
        <div class="data-row"><span>API STATUS:</span> <span id="api-status" class="val" style="color:yellow">STANDBY</span></div>
        <div class="data-row"><span>GESTURE:</span> <span id="gesture-disp" class="val">Detecting...</span></div>
        <div class="data-row"><span>ACTION:</span> <span class="val" style="color:#ff0066">HOLD üëç TO TRIGGER AI</span></div>
        
        <div id="ai-log">
            <div class="ai-msg">> System ready.</div>
            <div class="ai-msg">> Waiting for Thumbs Up...</div>
        </div>
    </div>

    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 1. USER CONFIGURATION ---
        const API_KEY = "AIzaSyA5gnCyfVKeg1JbolCILmkmpFtC28uFoQ8"; // Your Key
        const PARTICLE_COUNT = 15000;
        
        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 3. PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const targetColors = new Float32Array(PARTICLE_COUNT * 3);

        // Init Particles
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const x = (Math.random()-0.5)*50;
            const y = (Math.random()-0.5)*50;
            const z = (Math.random()-0.5)*50;
            
            positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
            targets[i*3] = x; targets[i*3+1] = y; targets[i*3+2] = z;
            
            colors[i*3] = 0; colors[i*3+1] = 1; colors[i*3+2] = 1; // Initial Cyan
            targetColors[i*3] = 0; targetColors[i*3+1] = 1; targetColors[i*3+2] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 4. SHAPE GENERATION LOGIC ---
        function setShape(shapeName) {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const idx = i*3;
                let x, y, z;

                if(shapeName === 'sphere') {
                    const r = 10;
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                else if(shapeName === 'heart') {
                    const t = Math.PI * (Math.random()-0.5)*2;
                    const u = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                    z = 2 * Math.cos(u) * Math.sin(t); // Thickness
                    x*=0.5; y*=0.5; z*=0.5;
                }
                else if(shapeName === 'cube') {
                    x = (Math.random()-0.5)*20;
                    y = (Math.random()-0.5)*20;
                    z = (Math.random()-0.5)*20;
                }
                else if(shapeName === 'spiral' || shapeName === 'galaxy') {
                    const angle = i * 0.05;
                    const r = i * 0.001 * 10;
                    x = Math.cos(angle) * r * 5;
                    y = (Math.random()-0.5)*5;
                    z = Math.sin(angle) * r * 5;
                }
                else {
                    // Default Scatter
                    x = (Math.random()-0.5)*40;
                    y = (Math.random()-0.5)*40;
                    z = (Math.random()-0.5)*40;
                }

                targets[idx] = x;
                targets[idx+1] = y;
                targets[idx+2] = z;
            }
        }

        // --- 5. GEMINI API INTEGRATION ---
        let isProcessing = false;

        async function triggerGeminiAnalysis(videoElement) {
            if (isProcessing) return;
            isProcessing = true;
            updateStatus("CONTACTING GEMINI...", "yellow");
            logAI("Capturing visual data...", "ai-loading");

            // 1. Capture Image from Video
            const canvas = document.createElement('canvas');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            const base64Image = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];

            // 2. Prepare Payload
            const prompt = `
                Look at the hand gesture in this image.
                1. Identify the gesture (e.g., Peace, Fist, Open Hand, Spock, Thumbs Up).
                2. Creatively assign a 3D Shape that matches the "mood" of the gesture (options: sphere, heart, cube, spiral, galaxy).
                3. Assign a Color (hex code) that matches the mood.
                4. Return ONLY a JSON object: {"gesture": "name", "shape": "shape_name", "color": "#RRGGBB"}.
            `;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`;
            const payload = {
                contents: [{
                    parts: [
                        { text: prompt },
                        { inline_data: { mime_type: "image/jpeg", data: base64Image } }
                    ]
                }]
            };

            // 3. Send Request
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                
                // 4. Parse Response
                const text = data.candidates[0].content.parts[0].text;
                // Cleanup json markdown if present
                const jsonStr = text.replace(/```json|```/g, '').trim();
                const result = JSON.parse(jsonStr);

                // 5. Apply Results
                logAI(`Gemini sees: ${result.gesture}`);
                logAI(`Morphing to: ${result.shape} (${result.color})`);
                
                setShape(result.shape);
                
                const col = new THREE.Color(result.color);
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    targetColors[i*3] = col.r;
                    targetColors[i*3+1] = col.g;
                    targetColors[i*3+2] = col.b;
                }

                updateStatus("ONLINE", "#00ffcc");
            } catch (error) {
                console.error(error);
                logAI("Error connecting to AI.", "red");
                updateStatus("ERROR", "red");
            } finally {
                // Cooldown
                setTimeout(() => { isProcessing = false; }, 2000);
            }
        }

        // --- 6. COMPUTER VISION (TRIGGER) ---
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        let thumbsUpFrames = 0;

        async function initVision() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO",
                numHands: 1
            });
            document.getElementById('loader').style.display = 'none';
            startWebcam();
        }

        function startWebcam() {
            const video = document.getElementById('webcam');
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                animate();
            });
        }

        // --- 7. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const video = document.getElementById('webcam');

            // Vision Logic
            if (handLandmarker && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    
                    // Simple Thumbs Up Detection logic
                    // Thumb tip (4) is higher (smaller Y) than Index knuckle (5)
                    // Other fingers curled (Tip y > PIP y)
                    const thumbIsUp = lm[4].y < lm[3].y && lm[4].y < lm[8].y;
                    const fingersCurled = lm[12].y > lm[10].y && lm[16].y > lm[14].y;

                    if(thumbIsUp && fingersCurled) {
                        thumbsUpFrames++;
                        document.getElementById('gesture-disp').innerText = "THUMBS UP detected";
                        document.getElementById('gesture-disp').style.color = "#00ffcc";
                        
                        // If held for 30 frames (~0.5s), trigger AI
                        if(thumbsUpFrames === 30 && !isProcessing) {
                            triggerGeminiAnalysis(video);
                        }
                    } else {
                        thumbsUpFrames = 0;
                        document.getElementById('gesture-disp').innerText = "Tracking...";
                        document.getElementById('gesture-disp').style.color = "#aaa";
                    }

                    // Move Center
                    const cx = (0.5 - lm[0].x) * 30; 
                    const cy = (0.5 - lm[0].y) * 20;
                    scene.position.x += (cx - scene.position.x) * 0.1;
                    scene.position.y += (cy - scene.position.y) * 0.1;
                }
            }

            // Particle Physics
            const p = geometry.attributes.position.array;
            const c = geometry.attributes.color.array;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const idx = i*3;
                p[idx] += (targets[idx] - p[idx]) * 0.05;
                p[idx+1] += (targets[idx+1] - p[idx+1]) * 0.05;
                p[idx+2] += (targets[idx+2] - p[idx+2]) * 0.05;

                c[idx] += (targetColors[idx] - c[idx]) * 0.05;
                c[idx+1] += (targetColors[idx+1] - c[idx+1]) * 0.05;
                c[idx+2] += (targetColors[idx+2] - c[idx+2]) * 0.05;
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            particleSystem.rotation.y += 0.002;

            renderer.render(scene, camera);
        }

        // Helpers
        function logAI(msg, cssClass = 'ai-msg') {
            const log = document.getElementById('ai-log');
            const div = document.createElement('div');
            div.className = cssClass;
            div.innerText = `> ${msg}`;
            log.prepend(div);
        }

        function updateStatus(text, color) {
            const el = document.getElementById('api-status');
            el.innerText = text;
            el.style.color = color;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initVision();
    </script>
</body>
</html>
